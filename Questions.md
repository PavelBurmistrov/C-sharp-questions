### Что такое CLR? Какие функции она выполняет?
- CLR (*Common Language Runtime*) - общеязыковая среда выполнения, которая может работать с разными языками программирования: *C#, C++, VB, F#,  Iron Python, Iron Ruby, IL* и тд. 
- Основные функции CLR: 
 1. Загрузка сборок    
 2. Управление памятью 
 3. Интеграция языков   
 4. Безопасность (верификация) 
 5. Обработка исключений
### Загрузка CLR. Если мы запускаем 2 или более программы на .NET - сколько экземпляров CLR у нас будет?
- *Загрузка CLR:*

1. **> К**омпилятор анализирует и проверяет исходный код. Генерирует управляемый модуль [PE32/PE32+ заголовок, CLR заголовок, метаданные, IL код] 
2. **> М**одули объединяются в сборку (для C# это CSC.exe) Если сборка содержит только управляемый код, то доп. модификаций исходного кода не требуется, и EXE и DLL будут правильно выполняться для Windows x64 и x86 
3. **> В** зависимости от указанной целевой платформы C# генерирует заголовок — PE32 или PE32+, а также включает в него требуемую процессорную архитектуру (или признак независимости от архитектуры) 
4. **> W**indows анализирует заголовок EXE-файла для определения того, какое именно адресное пространство необходимо для его работы — 32- или 64-разрядное 
5. **> W**inda загружает в адр. пространство соотв. версию библиотеки MSCorEE.dll 
6. **> О**сновной поток вызывает в MSCorEE.dll метод, который инициализирует CLR, загружает сборку EXE, и вызывает ее метод Main, в котором содержится точка входа 
7. **> З**агрузка CLR завершена.


- *Если мы запускаем 2 или более программы на .NET - сколько экзэмпляров CLR у нас будет?*

Столько экземпляров сколько и приложений.
JIT-компилятор хранит машинные команды в динамической памяти. Это значит, что скомпилированный код уничтожается по завершении работы приложения.
Для повторного вызова приложения или для параллельного запуска его второго
экземпляра (в другом процессе операционной системы) JIT-компилятору придется
заново скомпилировать IL-код в машинные команды. В зависимости от приложения
это может привести к существенному повышению затрат памяти по сравнению
с низкоуровневыми приложением, у которых находящийся в памяти код доступен
только для чтения и совместно используется всеми экземплярами приложения.
### JIT компилятор - что это такое и для чего он нужен?
Для выполнения какого-либо метода его IL-код должен быть преобразован в
машинные команды. Этим занимается JIT-компилятор (Just-In-Time) среды CLR.
Когда метод Main первый раз обращается к вызываемому методу в коде, вызывается
функция JITCompiler. Она отвечает за компиляцию IL-кода вызываемого метода
в собственные команды процессора. Поскольку IL-код компилируется непосредственно перед выполнением («just in time»), этот компонент CLR часто называют
JIT-компилятором.
<image src="https://user-images.githubusercontent.com/49167504/199069040-b2a58e3f-be01-403b-a321-6e365c5532ec.png" width="500">
<img src="https://user-images.githubusercontent.com/49167504/199069276-bebc56b0-4ce1-4e97-bb2a-bd74290bbe51.png" width="500">
 
### Быстродействие IL->EXE - это медленее чем обычный EXE? Или есть нюансы? Когда наблюдается снижение производительности, а когда нет?
 - *Быстродействие IL->EXE - это медленее чем обычный EXE?*
 
  В тот момент, когда JIT-компилятор компилирует IL-код в машинный код во время выполнения, он знает о среде выполнения больше, чем может знать неуправляемый компилятор.
И вот, почему IL->EXE может быть быстрее обычного EXE:
1. JIT-компилятор может определить, что приложение выполняется на процессоре Intel Pentium 4, и сгенерировать машинный код со специальными командами, поддерживаемыми Pentium 4. Обычно неуправляемые приложения компилируются с самым общим набором команд и не используют специальные команды, способные повысить эффективность приложения.
2. Если компьютер оснащен всего одним процессором, то JIT-компилятор не будет генерировать машинные команды для указанного фрагмента.
if (numberOfCPUs > 1) {
 ...
}
3. CLR может профилировать выполняемую программу и перекомпилировать IL в машинный код в процессе выполнения. Перекомпилированный код реорганизуется для сокращения ошибочного прогнозирования переходов на основании наблюдаемых закономерностей выполнения. Текущие версии CLR такую возможность не поддерживают, но возможно, она появится в будущих версиях
 4. Можно использовать утилиту Ngen.exe. Эта утилита компилирует весь IL-код сборки в машинный код и сохраняет его в файле на диске. В момент выполнения при загрузке сборки CLR автоматически проверяет, существует ли заранее откомпилированная версия сборки, и если существует — загружает ее, так что компиляция во время выполнения уже не требуется.
 - *Когда наблюдается снижение производительности, а когда нет?*
 
 Снижение производительности только при первом вызове метода. Все последующие «на максимальной скорости», т.к повторная верификация и компиляция не производятся. Для большинства приложений это снижение производительности незначительно. Выполнение самого метода обычно занимает больше времени, чем обращение к нему. Следует учесть, что JIT-компилятор среды CLR оптимизирует машинный код аналогично компилятору неуправляемого кода C++. И опять же: создание оптимизированного кода занимает больше времени, но при выполнении он гораздо производительнее, чем неоптимизированный.
### Что такое PDB файлы? Для чего они нужны?
Компилятор строит файл PDB (Program Database) только при
задании параметра дебаге. Файл PDB помогает отладчику
находить локальные переменные и связывать команды IL с исходным кодом.
Параметр /debug:full сообщает JIT-компилятору о том, что вы намерены заняться
отладкой сборки; JIT-компилятор сохраняет информацию о том, какой машинный код был сгенерирован для каждой команды IL. Это позволяет использовать
функцию JIT-отладки Visual Studio для связывания отладчика с уже работающим
процессом и упрощения отладки кода. Без параметра /debug:full компилятор по
умолчанию не сохраняет информацию о соответствии между IL и машинным кодом;
это несколько ускоряет компиляцию и сокращает затраты памяти. Если запустить
процесс в отладчике Visual Studio, то JIT-компилятор будет отслеживать информацию о соответствии IL и машинного кода (независимо от состояния параметра /
debug), если только вы не снимете флажок Suppress JIT Optimization On Module Load
(Managed Only) в Visual Studio.
### Безопасный и небезопасный код. Почему приложения на .NET считаются что являются безопасными?
 - *Безопасный и небезопасный код*
 
 По умолчанию компилятор C# компании Microsoft генерирует безопасный код - код, безопасность которого подтверждается в процессе верификации. Тем не менее компилятор Microsoft C# также позволяет разработчикам писать небезопасный код, способный напрямую работать с адресами памяти и манипулировать с байтами по этим адресам. Небезопасный код - это риск: может повредить структуры данных и использовать (создавать) уязвимости в системе безопасности. Все методы с небезопасным кодом помечены ключ. словом unsafe.
 - *Почему приложения на .NET - безопасныне?*
 
 В процессе компиляции IL в машинные инструкции CLR выполняется процедура, называемая *верификацией*— анализ кода IL и проверка безопасности всех операций. Например, верификация убеждается в том, что каждый метод вызывается с правильным количеством параметров, что все передаваемые параметры имеют правильный тип и тд. Вся информация о методах и типах, используемая в процессе верификации, хранится в метаданных управляемого модуля. Верификация управляемого кода гарантирует, что код не будет некорректно обращаться к памяти и не сможет повредить выполнению кода другого приложения. Это означает, что вы можете запустить несколько управляемых приложений в одном виртуальном адресном пространстве Windows.
### CLS/CTS - важно понимать что это такое и уметь ответить
 
 *CLS (Common Language Specification)* - определяет минимальный набор возможностей, которые должны поддерживаться всеми *CLS*-совместимыми языками. *CLS* определяет правила, которым должны соответствовать типы и методы с внешней видимостью, для того чтобы они могли использоваться в любом *CLS*-совместимом языке программирования.
 
 *CTS (Common Type System)* - описывает способ определения и поведение типов. *CTS* определяет набор правил, которыму должны следовать все языки при работе с типами: содерж. поле, метод, свойство, событие; задает правила видимости типов; задает правила наследования; срок жизни объектов и тд. Синтаксис определения типа зависит от выбранного языка, но поведение типа остается неизменным, потому что оно определяется спецификацией *CTS*. К примеру: если мы попытаемся на C++ наследоваться от нескольких базовых классов, то *CTS* не будет работать с ними, т.к позволяет быть производным только от одного класса => при создании такого управляемого кода компилятор C++/CLI выдаст ошибку. Ещё одно правило *CTS* - все типы являются производными от типа System.Object, т.е у каждого тиа есть мин. набор аспектов поведения.
 
<image src="https://user-images.githubusercontent.com/49167504/199208075-68b9103b-467e-4ac3-925f-0bbb7fdf6159.png" width="460"> <img src="https://user-images.githubusercontent.com/49167504/199209093-2f11b665-e10e-4de1-9f64-26bab0dfafd1.png" width="540">

### Обычные сборки и сборки со строгим именем. Что это такое? В чем отличия? Как идентифицируются сборки со строгим именем?
 
 Среда CLR поддерживает два вида сборок: **обычные** и со **строгими именами** *(strongly named assemblies)*. Они имеют одинаковую структуру: PE32/PE32+, CLR заголовок, метаданные, таблица манифеста, IL. 
 
 Отличаются тем, что "строгие" сборки подписаны при помощи пары ключей, уникально идентифицирующей издателя сборки. Эта пара ключей позволяет уникально идентифицировать сборку, обеспечивать ее безопасность, управлять ее версиями, а также развертывать в любом месте пользовательского жесткого диска или даже в Интернете.
 | Тип сборки                | Закрытое развертывание | Глобальное развертывание |
 |---------------------------|------------------------|--------------------------|
 | Сборка с нестрогим именем |           Да           |          Нет             |
 | Сборка со строгим именем  |           Да           |          Да              |
 
### Что такое GAC? Как он работает?

*GAC - (global assembly cache)* - глобальный кэш сборок, место, где располагаются совместно используемые сборки. Обычно *GAC* находится в каталоге %SystemRoot%\Microsoft.NET\Assembly. *GAC* имеет иерархическое строение и содержит множество вложенных каталогов, имена которых генерируются по определенному алгоритму. Ни в коем случае не следует копировать файлы сборок в *GAC* вручную — вместо этого надо использовать инструменты, созданные специально для этой цели. Эти инструменты «знают» внутреннюю структуру GAC и умеют генерировать надлежащие имена подкаталогов. 
 
 Глобальное развертывание сборки путем размещения ее в каталог GAC — это один из видов регистрации сборки в системе, хотя это никак не затрагивает реестр Windows. Установка сборок в GAC делает невозможными простые установку, копирование, восстановление, перенос и удаление приложения. По этой причине рекомендуется избегать глобального развертывания и использовать закрытое развертывание сборок всюду, где это только возможно.
